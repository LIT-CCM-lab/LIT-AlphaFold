#!/usr/bin/env python3


# Original Author: Dingquan Yu
# Modified by Luca Chiesa
# A script to create region information for create_multimer_features.py
# #
import os
import sys
import bz2
import random
from pathlib import Path
#from absl import app, flags, logging
import hydra
from omegaconf import OmegaConf

try:
   import cPickle as pickle
except:
   import pickle

import openmm
import jax

import logging


from litaf.objects import MultimericObject
from litaf.predict_structure import predict
from litaf.create_input import (create_pulldown,
                                            create_homooligomers,
                                            create_all_vs_all,
                                            create_custom_jobs)
from litaf.utils import setup_logging, create_colabfold_runners, load_mutation_dict

def predict_individual_jobs(
    multimer_object,
    cfg,
    model_runners: list,
    random_seed: int,
    save_multimer: bool = False,
    ) -> None:
    '''Run AlphaFold predictions on a single object 

    Parameters
    ----------
    multimer_object: MultimericObject or MonomericObject
        Object containing the MSA and template featrues necessary for prediction
    output_path: str
        Path where to store the results of the calculations
    model_runners: list
        Runners to use for prediction
    random_seed: int
        Value used as seed for random number generation
    save_multimers: bool, default = False
        Save the passed objects for further analysis or to reuse for new
         calculations
    pae_plots: bool, default=True
        Create and save PAE plots generated by AlphaFold

    Returns
    -------
    None
    '''
    output_path = os.path.join(cfg.output_path, multimer_object.description)
    Path(output_path).mkdir(parents=True, exist_ok=True)
    logging.info(f"now running prediction on {multimer_object.description}")

    if not isinstance(multimer_object, MultimericObject):
        multimer_object.input_seqs = [multimer_object.sequence]

    if save_multimer:
        if cfg.compress_multimer:
            pickle.dump(multimer_object, bz2.BZ2File(f"{output_path}.pkl.bz2", "w"))
        else:
            pickle.dump(multimer_object, open(f"{output_path}.pkl", "wb"))

    predict(
        model_runners,
        output_path,
        multimer_object.feature_dict,
        random_seed,
        cfg.benchmark,
        fasta_name=multimer_object.description,
        models_to_relax=cfg.models_to_relax,
        seqs=multimer_object.input_seqs,
        allow_resume=cfg.allow_resume,
        #optimize=cfg.optimize
    )


def predict_multimers(
    multimers: list,
    cfg,
    save_multimers: bool =False
    ) -> None:
    """
    Final function to predict multimers

    Parameters
    ----------
    multimers: list
        Multimeric and monomeric object to use for structure prediction
    save_multimers: bool, default=False
        Save the passed objects for further analysis or to reuse for new
         calculations

    Returns
    -------
    None
    """
    
    t_multi = []
    t_mono = []
    run_description = ''
    if cfg.run.dropout:
        logging.info("Run prediction using dropout for enhanced sampling")
        run_description = run_description+'_dropout'
    if not cfg.run.cluster_profile:
        logging.info("Run preddiction without cluster profiling")
        run_description = run_description+'_noclusterprofile'
    if cfg.run.max_seq is not None and cfg.run.max_extra_seq is not None:
        run_description = run_description+f'_MSA-subsampling-{cfg.run.max_seq}-{cfg.run.max_extra_seq}'
    for obj in multimers:
        obj.description = obj.description+run_description
        if isinstance(obj, MultimericObject):
            t_multi.append(obj)
        else:
            t_mono.append(obj)

    if len(t_multi) > 0 and cfg.run.get('num_cycle_multi', False):
        n = 5
        model_runners = create_colabfold_runners(
                            f'_multimer_{cfg.weights.multimer_type}',
                            n,
                            True,
                            cfg.run.num_cycle_multi,
                            cfg.weights.data_dir,
                            cfg.run.max_seq,
                            cfg.run.max_extra_seq,
                            cfg.run.num_predictions_per_model,
                            cfg.run.dropout,
                            cfg.run.cluster_profile,
                            cfg.save_all)

        random_seed = random.randrange(sys.maxsize // len(model_runners))

        for obj in t_multi:
            logging.info('Multimer object: '+obj.description)
            predict_individual_jobs(
                obj,
                cfg,
                model_runners=model_runners,
                random_seed=random_seed,
                save_multimer=save_multimers,
            )
        
    if len(t_mono) > 0:
        n = 2 if cfg.run.only_template else 5
        model_runners = create_colabfold_runners(
                            cfg.weights.monomer_type,
                            n,
                            cfg.run.use_templates,
                            cfg.run.num_cycle_mono,
                            cfg.weights.data_dir,
                            cfg.run.max_seq,
                            cfg.run.max_extra_seq,
                            cfg.run.num_predictions_per_model,
                            cfg.run.dropout,
                            cfg.run.cluster_profile,
                            cfg.save_all)
        random_seed = random.randrange(sys.maxsize // len(model_runners))
        for obj in t_mono:
            logging.info('Monomer object: '+obj.description)
            predict_individual_jobs(
                obj,
                cfg,
                model_runners=model_runners,
                random_seed=random_seed,
                save_multimer=save_multimers,
            )

@hydra.main(version_base=None, config_path="conf/predict", config_name="config")
def main(cfg):

    missing_keys: set[str] = OmegaConf.missing_keys(cfg)
    if missing_keys:
        raise RuntimeError(f"Got missing keys in config: {'  '.join(missing_keys)}")

    if not os.path.isdir(cfg.output_path):
        Path(cfg.output_path).mkdir(parents=True, exist_ok=True)

    setup_logging(os.path.join(cfg.output_path,
                                f'{cfg.logger_file}.log'))

    # check what device is available
    try:
        # check if TPU is available
        import jax.tools.colab_tpu
        jax.tools.colab_tpu.setup_tpu()
        logging.info('Running on TPU')
    except:
        if jax.local_devices()[0].platform == 'cpu':
            logging.info("WARNING: no GPU detected, will be using CPU")
        else:
            logging.info('Running on GPU')

    if cfg.mutate_msa_file:
        mutate_msa = load_mutation_dict(cfg.mutate_msa_file)
    else:
        mutate_msa = None

    if cfg.remove_msa_region:
        regions = cfg.remove_msa_region.split(',')
        output_region = []
        for r in regions:
            output_region.append((int(r.split("-")[0]), int(r.split("-")[1])))
    else:
        output_region = None

    create_functions = {'pulldown': create_pulldown,
                        'all_vs_all': create_all_vs_all,
                        'homo-oligomer': create_homooligomers,
                        'custom': create_custom_jobs,
                        }

    multimers = create_functions[cfg.mode](
                    cfg.input_file,
                    cfg.monomer_objects_dir,
                    pair_msa=not cfg.run.remove_pair_msa,
                    remove_msa=cfg.remove_unpaired_msa,
                    remove_template_msa=cfg.run.remove_template_msa,
                    mutate_msa = mutate_msa,
                    remove_msa_region = output_region,
                    remove_templates = not cfg.run.use_templates,
                    shuffle_templates = cfg.shuffle_templates,
                    paired_msa = cfg.modify_paired_msa,
                    unpaired_msa = cfg.modify_unpaired_msa,
                    multimer_templates = cfg.run.multimer_templates,
                    multi_monomer = cfg.multi_monomer
                )

    no_monomer_runner = True
    no_multimer_runner = True

    run_description = ''
    if cfg.run.dropout:
        logging.info("Run prediction using dropout for enhanced sampling")
        run_description = run_description+'_dropout'
    if not cfg.run.cluster_profile:
        logging.info("Run preddiction without cluster profiling")
        run_description = run_description+'_noclusterprofile'
    if cfg.run.max_seq is not None and cfg.run.max_extra_seq is not None:
        run_description = run_description+f'_MSA-subsampling-{cfg.run.max_seq}-{cfg.run.max_extra_seq}'

    for obj in multimers:
        if isinstance(obj, MultimericObject) and no_multimer_runner:
            n = 5
            model_runners = create_colabfold_runners(
                                f'_multimer_{cfg.weights.multimer_type}',
                                n,
                                True,
                                cfg.run.num_cycle_multi,
                                cfg.weights.data_dir,
                                cfg.run.max_seq,
                                cfg.run.max_extra_seq,
                                cfg.run.num_predictions_per_model,
                                cfg.run.dropout,
                                cfg.run.cluster_profile,
                                cfg.save_all)
            random_seed = random.randrange(sys.maxsize // len(model_runners))
            no_multimer_runner = False
        elif not isinstance(obj, MultimericObject) and no_monomer_runner:
            n = 2 if cfg.run.only_template else 5
            model_runners = create_colabfold_runners(
                                cfg.weights.monomer_type,
                                n,
                                cfg.run.use_templates,
                                cfg.run.num_cycle_mono,
                                cfg.weights.data_dir,
                                cfg.run.max_seq,
                                cfg.run.max_extra_seq,
                                cfg.run.num_predictions_per_model,
                                cfg.run.dropout,
                                cfg.run.cluster_profile,
                                cfg.save_all)
            random_seed = random.randrange(sys.maxsize // len(model_runners))
            no_monomer_runner = False
        obj.description = obj.description+run_description
        import pdb
        pdb.set_trace()
        predict_individual_jobs(
                obj,
                cfg,
                model_runners=model_runners,
                random_seed=random_seed,
                save_multimer=cfg.save_multimers,
            )


if __name__ == "__main__":
    main()
